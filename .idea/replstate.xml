<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1417692805324">{:repl-history {:ide [], :local [&quot;(clojure.string/replace \&quot;1xxx2yy3z4xxx5yy6\&quot; (re-groups (re-matcher #\&quot;(?&lt;=\\[)[^]]+(?=\\])\&quot;) \&quot;//[xxx][yy][z]\\n1xxx2yy3z4xxx5yy6\&quot;) \&quot;\\000\&quot;)&quot; &quot;(clojure.string/replace \&quot;1xxx2yy3z4xxx5yy6\&quot; (re-matcher #\&quot;(?&lt;=\\[)[^]]+(?=\\])\&quot; \&quot;//[xxx][yy][z]\\n1xxx2yy3z4xxx5yy6\&quot;) \&quot;\\000\&quot;)&quot; &quot;(clojure.string/replace \&quot;1xxx2yy3z4xxx5yy6\&quot; (re-groups (re-matcher #\&quot;(?&lt;=\\[)[^]]+(?=\\])\&quot; \&quot;//[xxx][yy][z]\\n1xxx2yy3z4xxx5yy6\&quot;)) \&quot;\\000\&quot;)&quot; &quot;(clojure.string/replace \&quot;1xxx2yy3z4xxx5yy6\&quot; (re-find #\&quot;(?&lt;=\\[)[^]]+(?=\\])\&quot; \&quot;//[xxx][yy][z]\\n1xxx2yy3z4xxx5yy6\&quot;) \&quot;\\000\&quot;)&quot; &quot;(clojure.string/replace \&quot;1xxx2yy3z4xxx5yy6\&quot; (re-seq #\&quot;(?&lt;=\\[)[^]]+(?=\\])\&quot; \&quot;//[xxx][yy][z]\\n1xxx2yy3z4xxx5yy6\&quot;) \&quot;\\000\&quot;)&quot; &quot;(clojure.string/replace \&quot;1xxx2yy3z4xxx5yy6\&quot; (vector (re-seq #\&quot;(?&lt;=\\[)[^]]+(?=\\])\&quot; \&quot;//[xxx][yy][z]\\n1xxx2yy3z4xxx5yy6\&quot;)) \&quot;\\000\&quot;)&quot; &quot;(vector (re-seq #\&quot;(?&lt;=\\[)[^]]+(?=\\])\&quot; \&quot;//[xxx][yy][z]\\n1xxx2yy3z4xxx5yy6\&quot;))&quot; &quot;(vec (re-seq #\&quot;(?&lt;=\\[)[^]]+(?=\\])\&quot; \&quot;//[xxx][yy][z]\\n1xxx2yy3z4xxx5yy6\&quot;))&quot; &quot;(clojure.string/replace 1xxx2yy3z4xxx5yy6 (vec (re-seq #\&quot;(?&lt;=\\[)[^]]+(?=\\])\&quot; \&quot;//[xxx][yy][z]\\n1xxx2yy3z4xxx5yy6\&quot;)) \&quot;\\000\&quot;) &quot; &quot;(clojure.string/replace \&quot;1xxx2yy3z4xxx5yy6\&quot; (vec (re-seq #\&quot;(?&lt;=\\[)[^]]+(?=\\])\&quot; \&quot;//[xxx][yy][z]\\n1xxx2yy3z4xxx5yy6\&quot;)) \&quot;\\000\&quot;) &quot; &quot;(reduce \n  )&quot; &quot;(reduce #(clojure.string/replace \&quot;1xxx2yy3zxxx4\&quot; % \&quot;\\000\&quot;) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;])&quot; &quot;(reduce #(clojure.string/replace \&quot;1xxx2yy3zxxx4\&quot; (re=pattern %) \&quot;\\000\&quot;) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;])&quot; &quot;(reduce #(clojure.string/replace \&quot;1xxx2yy3zxxx4\&quot; (re-pattern %) \&quot;\\000\&quot;) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;])&quot; &quot;(reduce (fn [x] (clojure.string/replace \&quot;1xxx2yy3zxxx4\&quot; (re-pattern x) \&quot;\\000\&quot;)) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;])&quot; &quot;(reduce (fn [x] (clojure.string/replace  (re-pattern x) \&quot;\\000\&quot;)) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;])&quot; &quot;(reduce (fn [x] (clojure.string/replace \&quot;1xxx2yy3zxxx4\&quot;(re-pattern x) \&quot;\\000\&quot;)) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;])&quot; &quot;(reduce\n  (fn [x] (clojure.string/replace \&quot;1xxx2yy3zxxx4\&quot; x \&quot;\\000\&quot;)) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;])&quot; &quot;(reduce (fn [x] (clojure.string/replace \&quot;1xxx2yy3zxxx4\&quot; x \&quot;\\000\&quot;)) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;])&quot; &quot;(reduce #(clojure.string/replace \&quot;1xxx2yy3zxxx4\&quot; %1 \&quot;\\000\&quot;) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;])&quot; &quot;(let [s \&quot;1xxx2yy3zxxx4\&quot;] (reduce #(clojure.string/replace s % \&quot;\\000\&quot;) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;]))&quot; &quot;(let [s \&quot;1xxx2yy3zxxx4\&quot;] (reduce #(clojure.string/replace s %1 \&quot;\\000\&quot;) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;]))&quot; &quot;(let [s \&quot;1xxx2yy3zxxx4\&quot;] (reduce #(clojure.string/replace s %2 \&quot;\\000\&quot;) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;]))&quot; &quot;(let [s \&quot;1xxx2yy3zxxx4\&quot;] (reduce #(clojure.string/replace %1 %2 \&quot;\\000\&quot;) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;]))&quot; &quot;(reduce #(clojure.string/replace %1 %2 \&quot;\\000\&quot;) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;])&quot; &quot;(reduce #(clojure.string/replace %2 %1 \&quot;\\000\&quot;) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;])&quot; &quot;(reduce #(clojure.string/replace \&quot;sss\&quot; %1 \&quot;\\000\&quot;) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;])&quot; &quot;(let [x \&quot;1xxx2yy3zxxx4\&quot;] (reduce #(clojure.string/replace x %1 \&quot;\\000\&quot;) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;])&quot; &quot;(let [x \&quot;1xxx2yy3zxxx4\&quot;](reduce #(clojure.string/replace x % \&quot;\\000\&quot;) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;]))&quot; &quot;(let [x \&quot;1xxx2yy3zxxx4\&quot;](reduce #(clojure.string/replace x %1 \&quot;\\000\&quot;) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;]))&quot; &quot;(let [x \&quot;1xxx2yy3zxxx4\&quot;](reduce #(clojure.string/replace x %2 \&quot;\\000\&quot;) [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;]))&quot; &quot;(reduce #(clojure.string/replace %1 %2 \&quot;\\000\&quot;) \&quot;1xxx2yy3zxxx4\&quot; [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;])&quot; &quot;(reduce #(clojure.string/replace %1 %2 \&quot;\\000\&quot;) \&quot;1xxx2yy3z4xxx5\&quot; [\&quot;xxx\&quot; \&quot;yy\&quot; \&quot;z\&quot;])&quot; &quot;\n(reduce #(str/replace %1 %2 \&quot;\\000\&quot;) num-str delim-vec)&quot; &quot;(reduce #(clojure.string/replace %1 %2 \&quot;\\000\&quot;) num-str delim-vec)&quot; &quot;(def num-str 1,2,3)&quot; &quot;(reduce #(clojure.string/replace %1 %2 \&quot;\\000\&quot;) \&quot;1,2,3\&quot; [\&quot;,\&quot; \&quot;\\n\&quot;])&quot; &quot;(map #(Integer/parseInt %) (reduce #(clojure.string/replace %1 %2 \&quot;\\000\&quot;) \&quot;1,2,3\&quot; [\&quot;,\&quot; \&quot;\\n\&quot;]))&quot; &quot;(map #(Integer/parseInt %) (vec (reduce #(clojure.string/replace %1 %2 \&quot;\\000\&quot;) \&quot;1,2,3\&quot; [\&quot;,\&quot; \&quot;\\n\&quot;])))&quot; &quot;(map #(Integer/parseInt %) (vector (reduce #(clojure.string/replace %1 %2 \&quot;\\000\&quot;) \&quot;1,2,3\&quot; [\&quot;,\&quot; \&quot;\\n\&quot;])))&quot; &quot;(clojure.string/split (reduce #(clojure.string/replace %1 %2 \&quot;\\000\&quot;) num-str delim-vec) #\&quot;\\000\&quot;)&quot; &quot;(clojure.string/split (reduce #(clojure.string/replace %1 %2 \&quot;\\000\&quot;) \&quot;1,2,3\&quot; [\&quot;,\&quot; \&quot;\\n\&quot;]) #\&quot;\\000\&quot;)&quot; &quot;(clojure.string/split (reduce #(clojure.string/replace %1 %2 \&quot;\\000\&quot;) \&quot;//,\\n1,2,3\&quot; [\&quot;,\&quot; \&quot;\\n\&quot;]) #\&quot;\\000\&quot;)&quot; &quot;(clojure.string/split (reduce #(clojure.string/replace %1 %2 \&quot;\\000\&quot;) \&quot;1,2,3\&quot; [\&quot;,\&quot;]) #\&quot;\\000\&quot;)&quot; &quot;(re-seq #\&quot;(?(?&lt;=\\[)[^]]+(?=\\])|(?&lt;=//)[.](?=\\n))\&quot; \&quot;//;\\n\&quot;)&quot; &quot;(re-seq #\&quot;(?(?&lt;=\\[)[^]]+(?=\\])|(?&lt;=//).(?=\\n))\&quot; \&quot;//;\\n\&quot;)&quot; &quot;(re-seq #\&quot;(?(?&lt;=\\[)[^]]+(?=\\])|(?&lt;=//)[.](?=\\n)))\&quot; \&quot;//;\\n\&quot;)&quot; &quot;(re-seq #\&quot;(?&lt;=\\[)[^]]+(?=\\])|(?&lt;=//)[.](?=\\n)\&quot; \&quot;//;\\n\&quot;)&quot; &quot;(re-seq #\&quot;(?&lt;=\\[)[^]]+(?=\\])|(?&lt;=//)[^\\[]\&quot; \&quot;//;\\n\&quot;)&quot; &quot;(re-seq #\&quot;(?&lt;=\\[)[^]]+(?=\\])|(?&lt;=//)[^\\[]\&quot; \&quot;//[;;;][**]\\n\&quot;)&quot; &quot;(def RGX_MULT_DELIM \&quot;(?&lt;=\\\\[)[^\\\\]]+(?=\\\\])\&quot;)\n(def RGX_SINGLE_DELIM \&quot;(?&lt;=//)[^\\\\[)\&quot;)\n&quot; &quot;(def RGX_MULT_DELIM \&quot;(?&lt;=\\\\[)[^\\\\]]+(?=\\\\])\&quot;)\n(def RGX_SINGLE_DELIM \&quot;(?&lt;=//)[^\\\\[])\&quot;)\n&quot; &quot;(def RGX_MULT_DELIM \&quot;(?&lt;=\\\\[)[^\\\\]]+(?=\\\\])\&quot;)\n(def RGX_SINGLE_DELIM \&quot;(?&lt;=\\\\/\\\\/)[^\\\\[])\&quot;)\n&quot; &quot;(def RGX_MULT_DELIM \&quot;(?&lt;=\\\\[)[^\\\\]]+(?=\\\\])\&quot;)\n(def RGX_SINGLE_DELIM \&quot;(?&lt;=//)[^[]\&quot;)\n&quot; &quot;(def RGX_MULT_DELIM \&quot;(?&lt;=\\\\[)[^\\\\]]+(?=\\\\])\&quot;)\n(def RGX_SINGLE_DELIM \&quot;(?&lt;=//)[^\\\\[]\&quot;)\n&quot; &quot;(re-pattern (str RGX_MULT_DELIM \&quot;|\&quot; RGX_SINGLE_DELIM))&quot; &quot;[1 2 3 4]&quot; &quot;{\&quot;aaa\&quot; 1 \&quot;bbb\&quot; 2}&quot; &quot;(get {\&quot;bbb\&quot; 2, \&quot;aaa\&quot; 1} \&quot;aaa\&quot;)&quot; &quot;#{1 2 3}&quot; &quot;(str \&quot;a\&quot; \&quot;b\&quot;)&quot; &quot;(func arg\n      (func arg\n            arg (func arg\n                      (func \n                        (func \n                          (func arg)\n                          arg)\n                        arg))))&quot; &quot;map&quot; &quot;'map&quot; &quot;(map [1 2 3 4])&quot; &quot;(1 \&quot;a\&quot; 2 \&quot;b\&quot; 3 \&quot;c\&quot;)&quot; &quot;[1 \&quot;a\&quot; 2 \&quot;b\&quot; 3 \&quot;c\&quot;]&quot; &quot;([1 \&quot;a\&quot; 2 \&quot;b\&quot; 3 \&quot;c\&quot;] 2)&quot; &quot;(get [1 \&quot;a\&quot; 2 \&quot;b\&quot; 3 \&quot;c\&quot;] 2)&quot; &quot;(hash-map [1 \&quot;a\&quot; 2 \&quot;b\&quot; 3 \&quot;c\&quot;])&quot; &quot;(hash-map (1 \&quot;a\&quot; 2 \&quot;b\&quot; 3 \&quot;c\&quot;))&quot; &quot;{1 \&quot;a\&quot; 2 \&quot;b\&quot; 3 \&quot;c\&quot;}&quot; &quot;({1 \&quot;a\&quot; 2 \&quot;b\&quot; 3 \&quot;c\&quot;} 2)&quot; &quot;(map #(Integer/parseInt) [\&quot;1\&quot; \&quot;2\&quot; \&quot;3\&quot;])&quot; &quot;(map #(Integer/parseInt %) [\&quot;1\&quot; \&quot;2\&quot; \&quot;3\&quot;])&quot; &quot;(1 2 3)&quot; &quot;'(1 2 3)&quot; &quot;(println \&quot;hello\&quot;)&quot; &quot;(doc 'stringcalc.core/add)&quot; &quot;(doc add)&quot; &quot;(doc stringcalc.core/add)&quot; &quot;  (compile 'stringcalc.NegativesNotAllowedException)&quot; &quot;(Integer/parseInt 1.33)&quot; &quot;(Integer/parseInt \&quot;1.33\&quot;)&quot; &quot;(int 1.22)&quot; &quot;(int 1.99)&quot; &quot;(int 2.99)&quot; &quot;(range 1000)&quot; &quot;(loop [v (range 1000)\n       t 0]\n  (if (empty? v)\n    t\n    (recur (rest v)\n           (if (or (compare-divisible (first v) 3)\n                   (compare-divisible (first v) 5)\n                   )))))&quot; &quot;(loop [v (range 1000)\n       t 0]\n  (if (empty? v)\n    t\n    (recur (rest v)\n           (if (or (compare-divisible (first v) 3)\n                   (compare-divisible (first v) 5))\n             (+ t (first v))\n             t\n             ))))&quot; &quot;calc&quot; &quot;[]&quot; &quot;1000&quot; &quot;1001&quot; &quot;t&quot; &quot;(ns stringcalc.euler)\n\n(defn compare-divisible [value num]\n  (= (int (/ value num)) (/ value num))\n)\n\n(loop [v (range numrange)\n         t 0]\n    (if (empty? v)\n      t\n      (recur (rest v)\n             (if (or (compare-divisible (first v) 3)\n                     (compare-divisible (first v) 5))\n               (+ t (first v))\n               t\n               ))))\n&quot; &quot;(ns stringcalc.euler)\n\n(defn compare-divisible [value num]\n  (= (int (/ value num)) (/ value num))\n)\n\n(defn calc [numrange]\n  (loop [v (range numrange)\n         t 0]\n    (if (empty? v)\n      t\n      (recur (rest v)\n             (if (or (compare-divisible (first v) 3)\n                     (compare-divisible (first v) 5))\n               (+ t (first v))\n               t\n               )))))\n\n(calc 10)&quot; &quot;(ns stringcalc.euler)\n\n(defn compare-divisible [value num]\n  (= (int (/ value num)) (/ value num))\n)\n\n(defn calc [numrange]\n  (loop [v (range numrange)\n         t 0]\n    (if (empty? v)\n      t\n      (recur (rest v)\n             (if (or (compare-divisible (first v) 3)\n                     (compare-divisible (first v) 5))\n               (+ t (first v))\n               t\n               )))))\n\n(calc 1000)&quot; &quot;(ns stringcalc.euler)\n\n(defn compare-divisible [value num]\n  (= (int (/ value num)) (/ value num)))\n\n  (loop [v (range 1000)\n         t 0]\n    (if (empty? v)\n      t\n      (recur (rest v)\n             (if (or (compare-divisible (first v) 3)\n                     (compare-divisible (first v) 5))\n               (+ t (first v))\n               t))))&quot; &quot;(ns stringcalc.euler-problem-0001)\n\n(defn compare-divisible [value num]\n  (= (int (/ value num)) (/ value num)))\n\n(loop [v (range 1000)\n       t 0]\n  (if (empty? v)\n    t\n    (recur (rest v)\n           (if (or (compare-divisible (first v) 3)\n                   (compare-divisible (first v) 5))\n             (+ t (first v))\n             t))))&quot; &quot;(compile 'stringcalc.NegativesNotAllowedException)&quot;], :remote []}}</component>
</project>

